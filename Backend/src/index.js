import express from "express";
import dotenv from "dotenv";
import { exec } from "child_process";
import cors from "cors";
import multer from "multer";
import path from "path";
import fs from "fs";
import bodyParser from "body-parser";
import { fileURLToPath } from "url";
// const AdmZip = require("adm-zip");
import AdmZip from "adm-zip";
// const { v4: uuidv4 } = require('uuid');
import { v4 as uuidv4 } from "uuid";
import { error } from "console";
import { stderr, stdout } from "process";
import pool from './database.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({
  path: "./.env",
});

const port = process.env.PORT || 4002;
const app = express();
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "src/uploads");
  },
  filename: function (req, file, cb) {
    cb(null, "latest.apk");
  },
});

const upload = multer({ storage: storage });

app.post("/upload", upload.single("apkFile"), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: "No file uploaded" });
  }
  res.json(req.file);
});

app.get("/run-adb-command", (req, res) => {
  const adbDevicesCommand = "/usr/bin/adb devices";

  exec(adbDevicesCommand, (error, stdout, stderr) => {
    if (error) {
      console.log("ERROR IN ADB");
      console.error("Error executing ADB devices command 1:", error);
      res.status(500).json({ error: "Error executing ADB devices command 2" });
      return;
    }
    console.log("ADB devices command output:", stdout);

    const devicesOutput = stdout
      .split("\n")
      .filter(
        (line) =>
          line.trim().length > 0 && !line.includes("List of devices attached")
      )
      .map((line) => line.split("\t")[0]);

    let commands = [];
    if (devicesOutput.length > 0) {
      commands = [
        "reboot",
        "shell dumpsys battery",
        "shell dumpsys bluetooth_manager",
        "shell dumpsys wifi",
        "shell pm list packages",
        "shell wm size",
        "shell getprop",
        "shell df",
        "shell top",
        "shell ip address show",
        "shell dumpsys sensorservice",
        "shell ifconfig",
        "shell dumpsys connectivity",
        "shell dumpsys thermalservice",
        "shell dumpsys media.camera"
      ];
    }
    res.json({ devices: devicesOutput, commands });
  });
});


app.get("/execute-adb-command/:deviceID/:command", (req, res) => {
  const adbDeviceID = req.params.deviceID;
  const adbCommand = req.params.command;

  // Sanitize command input to prevent injection attacks
  if (!adbDeviceID || !adbCommand) {
    return res.status(400).json({ error: "Invalid device ID or command" });
  }

  // Construct full ADB command and log it
  const fullAdbCommand = `adb -s ${adbDeviceID} ${adbCommand}`;
  console.log("Executing ADB command:", fullAdbCommand);

  // Execute the ADB command with increased buffer size (1 MB)
  exec(fullAdbCommand, { maxBuffer: 5 * 1024 * 1024 }, (error, stdout, stderr) => {
    if (error) {
      console.error("Error executing ADB command:", error);
      return res.status(500).json({ error: "Failed to execute ADB command" });
    }

    // Handle standard error output if any
    if (stderr) {
      console.error("ADB command stderr:", stderr);
      return res.status(500).json({ error: "ADB command execution error", details: stderr });
    }

    // Successfully executed ADB command
    console.log("ADB command output:", stdout);
    res.json({ output: stdout });
  });
});


function getFilePathForAPKLeaks(toolPath, stdout, tool, apkInfo) {
  let str = "** Results saved into '";
  console.log(`Stdout : --${stdout}--`);
  let fileName = "results.txt";
  console.log("File name : ", fileName);
  let startIndex = toolPath.split("").reverse().join("").indexOf("/");
  let toolPathWithoutTool = toolPath
  .split("")
  .reverse()
  .join("")
  .slice(startIndex)
  .split("")
  .reverse()
  .join("");
  console.log("tool path : ", toolPathWithoutTool);
  const filePath = path.join(toolPathWithoutTool, fileName);
  console.log("file path : ", filePath);
  return filePath;
 }

function renameToApk(filePath) {
  try {
    const fileExt = path.extname(filePath);
    console.log(`-----\nExtension : ${fileExt}\n------`);
    if (fileExt !== ".apk") {
      const newFilePath = filePath + ".apk";
      fs.renameSync(filePath, newFilePath);

      console.log("File renamed successfully:", newFilePath);
    } else {
      console.log("File already has .apk extension:", filePath);
    }
  } catch (error) {
    console.error("Error renaming file:", error);
  }
}

app.post("/run-command", (req, res) => {
  console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
  const { tool, apkInfo } = req.body;
  console.log("apkinfo:", apkInfo);
  let toolPath = "";
  let command = "";
  let filePath = "";
  let resultFilePath = "";
  if (tool === "Androwarn") {
    toolPath = "/home/lavkush/Desktop/thesis/androwarn/androwarn.py";
    command = `python3 ${toolPath} -i "${apkInfo.path.replace(
      /\\/g,
      "\\\\"
    )}" -r txt -v 1`;
  } else if (tool === "Androbugs") {
    toolPath = "/home/anshul/AndroBugs_Framework/androbugs.py";
    command = `python2 "${toolPath}" -f "${apkInfo.path.replace(
      /\\/g,
      "\\\\"
    )}"`;
  } else if (tool === "qark") {
    renameToApk(apkInfo.path);
    toolPath = "/home/anshul/qark-venv/lib/python3.11/site-packages/qark/qark.py";
    // command = `qark --apk ${apkInfo.path} --report-type json`;
    // command = `source /home/anshul/qark-venv/bin/activate && qark --apk ${apkInfo.path}`
    command = `bash -c "source /home/anshul/qark-venv/bin/activate && qark --apk ${apkInfo.path} --report-type json"`;
    console.log("command : ",command);
  }  else if (tool === "APKLeaks") {
    toolPath = "/home/anshul/apkleaks.py";
    const resultFilePath = "/home/anshul/result.txt";

    // Clear the result file before running APKLeaks
    fs.writeFile(resultFilePath, '', (err) => {
      if (err) {
        console.error(`Error clearing result file: ${err.message}`);
        return res.status(500).json({ error: "Failed to clear the result file" });
      }

      // Now run the APKLeaks command
      const command = `apkleaks -f ${apkInfo.path} -o ${resultFilePath}`;

      exec(command, { stdio: "pipe" }, (error, stdout, stderr) => {
        console.log("YOUYOU : ", command);
        console.log("OUT : ", stdout);
        
        if (error) {
          console.error(`Error running APKLeaks: ${error.message}`);
          return res.status(500).json({ error: "Error running APKLeaks" });
        }

        fs.readFile(resultFilePath, 'utf8', (err, data) => {
          if (err) {
            console.error(`Error reading result file: ${err.message}`);
            return res.status(500).json({ error: "Failed to read the result file" });
          }

          res.setHeader("Content-Type", "text/plain");
          return res.send(data);
        });
      });
    });

    return; // Ensure no further code is executed for APKLeaks
  }
  else {
    return res.status(400).json({ error: "Invalid tool" });
  }

  exec(command, { stdio: "pipe" }, (error, stdout, stderr) => {
    let str = "Backend";
    console.log("YOUYOU : ",command)
    console.log("OUT : ",stdout)
    // if (tool == "APKLeaks") {
    //   filePath = "/home/anshul/result.txt";

    //   const resultFilePath = "/home/anshul/result.txt";
    //   // if (resultFileMatch) {
    //   //   resultFilePath = resultFileMatch[1];
    //   // } else {
    //   //   console.error("Could not find the result file path in the output");
    //   //   return res.status(500).json({ error: "Could not find the result file path in the output" });
    //   // }

    //   fs.readFile(resultFilePath, 'utf8', (err, data) => {
    //     if (err) {
    //       console.error(`Error reading result file: ${err.message}`);
    //       return res.status(500).json({ error: "Failed to read the result file" });
    //     }

    //     // Send the file content as response
    //     res.setHeader("Content-Type", "text/plain");
    //     return res.send(data);
    //   });
    // } 
      if (tool == "qark") {
        str = "Finish writing report to";
      }
      console.log("ssssss : ", stdout);
      let ind = stdout.indexOf(str) + str.length + 1;
      let fileName = stdout.slice(ind);
      if (tool == "Androwarn") {
        var commaInd = fileName.indexOf("'");
      } else if (tool == "Androbugs") {
        var commaInd = fileName.indexOf(" >>>");
      } else if (tool == "qark") {
        var commaInd = fileName.indexOf(".json") + 5;
      }


      fileName = fileName.slice(0, commaInd);
      console.log("file name : ", fileName);
      filePath = path.join(__dirname, fileName);
      console.log("file path : ", filePath);
      if (tool == "qark") filePath = fileName;

      if (tool === "Androwarn") {
        let sourcePath = path.resolve(__dirname, "..");
        sourcePath = path.join(sourcePath, fileName);
        // filePath = filePath + "/reports";
        const destinationPath =
          path.resolve(__dirname, "..") + "/Reports/" + fileName;
        console.log("SSSSSSSSSSSSSSSSSS : ", sourcePath);
        console.log("DDDDDDDDDDDDDDDDDD : ", destinationPath);
        fs.rename(sourcePath, destinationPath, (err) => {
          if (err) {
            console.error(`Error moving the file: ${err}`);
          } else {
            console.log("File moved successfully");
          }
        });
        filePath = destinationPath;
      }
      if (tool === "Androbugs") {
        console.log("Before Androbugs : ", filePath);
        filePath = path.join(__dirname, "..", fileName);
        console.log("After Androbugs : ", filePath);
      }
    

    console.log("OOOOOOOOOOOOOOOOOOOOOO : ", filePath);


    // ################## STORE IN DATABASE ###################

    // const currentDateTime = new Date().toISOString();
    // const insertqry = `INSERT INTO testreport (toolname, time_of_test, reportlocation, device ) VALUES ( '${tool}', '${currentDateTime}', '${filePath}', '${apkInfo.originalname}' )`;
    // pool
    //   .query(insertqry)
    //   .then((response) => {
    //     console.log("DATA SAVED");
    //     console.log(response);
    //   })
    //   .catch((err) => {
    //     console.log(err);
    //   });

    // #####################################################


    if (fs.existsSync(filePath)) {
      console.log("in if block");
      res.setHeader("Content-Type", "text/plain");
      res.setHeader(
        "Content-Disposition",
        'attachment; filename="downloaded_file.txt"'
      );
      const fileStream = fs.createReadStream(filePath);
      return fileStream.pipe(res);
    } else {
      console.log("in else block");
      res.status(404).json({ error: "File not found" });
    }
  });
});

const nmapCommands = {
  Version: "nmap --version",
  "TCP SYN Scan": "sudo nmap -sS",
  "TCP Connect Scan": "sudo nmap -sV",
  "UDP Scan": "sudo nmap -sU",
  "Host Scan": "sudo nmap -sn",
};

app.post("/run-tool", (req, res) => {
  const { tool, nmapFunctionality, ipAddress } = req.body;

  if (
    tool === "nmap" &&
    nmapFunctionality &&
    nmapCommands[nmapFunctionality] &&
    ipAddress
  ) {
    // const command = `${nmapCommands[nmapFunctionality]} ${ipAddress}`;
    // // const expectScript = path.join(__dirname, "run_nmap_expect.exp");
    // // const fullCommand = `${expectScript} "${command}"`;
    // const fullCommand = command;
    // exec(fullCommand, (error, stdout, stderr) => {
    //   if (error) {
    //     console.error(`Error executing nmap command: ${error.message}`);
    //     return res
    //       .status(500)
    //       .json({ error: "An error occurred while running the tool" });
    //   }
    //   if (stderr) {
    //     console.error(`nmap command stderr: ${stderr}`);
    //   }

    //   res.json({ report: stdout });
    // });
    const command = `${nmapCommands[nmapFunctionality]} ${ipAddress}`;
    const expectScript = path.join(__dirname, "run_nmap_expect.exp");
    const fullCommand = `${expectScript} "${command}"`;
    const uniqueId = uuidv4(); 
    const filePath = `Reports/nmap_${uniqueId}.txt`;

    fs.appendFileSync(filePath, `nmapFunctionality: ${nmapFunctionality}\n`);

    // Execute the command and redirect stdout to a file
    exec(`${fullCommand} >> ${filePath}`, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error executing nmap command: ${error.message}`);
        return res
          .status(500)
          .json({ error: "An error occurred while running the tool" });
      }
      if (stderr) {
        console.error(`nmap command stderr: ${stderr}`);
        s;
      }
      fs.readFile(filePath, "utf8", (err, data) => {
        if (err) {
          console.error(`Error reading file: ${err}`);
          return res
            .status(500)
            .json({ error: "An error occurred while reading the output file" });
        }
        // console.log("rRRRRRRRRRRRRRR ------------- :",data);
        // console.log("finised")
        res.json({ report: data });
      });
    });

    // ################## STORE IN DATABASE ###################

    const currentDateTime = new Date().toISOString();
    const insertqry = `INSERT INTO testreport (toolname, time_of_test, reportlocation, device ) VALUES ( '${tool}', '${currentDateTime}', '${filePath}', '${ipAddress}' )`;
    pool
      .query(insertqry)
      .then((response) => {
        console.log("DATA SAVED");
        console.log(response);
      })
      .catch((err) => {
        console.log(err);
      });

    // #####################################################

      

  } else if (tool === "BurpSuite") {
    const command = "burpsuite";
    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error executing BurpSuite command: ${error.message}`);
        return res
          .status(500)
          .json({ error: "An error occurred while running the tool" });
      }
      if (stderr) {
        console.error(`BurpSuite command stderr: ${stderr}`);
      }
      // res.json({ report: stdout });
    });
    res.json("BurpSuite completed");
  } else {
    res.status(400).json({ error: "Invalid request" });
  }
});

app.post("/apktool/run", upload.single("apkFile"), (req, res) => {
  console.log("------------------------------lmkl--");
  req.file.filename = req.file.filename.replace(".apk", "");
  const apkFilePath = req.file.path;
  req.file.path = req.file.path.replace(".apk", "");
  console.log(req.file);

  if (!apkFilePath) {
    return res.status(400).json({ error: "No APK file uploaded" });
  }

  exec(`apktool d -f ${apkFilePath}`, (error, stdout, stderr) => {
    if (error) {
      console.log("hello");
      console.error("Error running apktool:", error);
      return res.status(500).json({ error: "Error running apktool" });
    }

    console.log("apktool : ",stdout)

    const outputName = stdout
      .split("\n")
      .find((line) => line.startsWith("I: Using Apktool"))
      .split(" ")[5];
    // const outputPath = outputName + ".out";
    const outputPath = outputName;
    if (!outputPath) {
      console.error("Error extracting output path");
      return res.status(500).json({ error: "Error extracting output path" });
    }
    console.log("output path : ", outputPath);
    const reportFolder = path.join(__dirname, "/uploads/");
    const reportZip = `${outputName}.zip`;
    console.log(`reportFolder :${reportFolder}`);
    const zipPath = path.join(__dirname, reportZip);

    const latestFolderPath = path.join(__dirname, "../latest");
    const manifestFilePath = path.join(latestFolderPath, "AndroidManifest.xml");

    // const zip = new AdmZip();
    // zip.addLocalFolder(reportFolder);
    // zip.writeZip(zipPath);
    // console.log("Full path : ", zipPath);

    // if (fs.existsSync(zipPath)) {
    //   console.log("in if block");
    //   // res.setHeader("Content-Type", "application/zip");
    //   // res.setHeader(
    //   //   "Content-Disposition",
    //   //   'attachment; filename="downloaded_file.zip"'
    //   // );
    //   res.status(200).json("Decoded APK Successfully.")
    //   const fileStream = fs.createReadStream(zipPath);
    //   fileStream.pipe(res);
    // } 
    if (fs.existsSync(manifestFilePath)) {
      console.log("AndroidManifest.xml found. Reading file...");

      // Read the content of the AndroidManifest.xml
      fs.readFile(manifestFilePath, "utf8", (err, data) => {
        if (err) {
          console.error("Error reading AndroidManifest.xml:", err);
          return res.status(500).json({ error: "Error reading AndroidManifest.xml" });
        }

        console.log("Successfully read AndroidManifest.xml");
        
        // Send the content of AndroidManifest.xml to the frontend
        res.status(200).json({ message: "Decoded APK Successfully.", manifestContent: data });
      });
    }
    else {
      console.log("in else block");
      res.status(404).json({ error: "File not found" });
    }
  });
});


// ***********************************

app.get("/readfile", (req, res) => {
  const filePath = req.query.path;
  fs.readFile(filePath, "utf8", (err, data) => {
    if (err) {
      return res.status(500).send("Error reading file");
    }
    res.send(data);
  });
});

// ***********************************

//************************************

app.get("/retrive", (req, res) => {
  const qry = `SELECT * FROM testreport;`;
  pool
    .query(qry)
    .then((response) => {
      console.log("Query successful");
      res.json(response.rows); // Send the result rows as JSON
    })
    .catch((err) => {
      console.error("Query error", err);
      res.status(500).send("An error occurred while retrieving the data");
    });
});

// *************************************

app.post("/jd-gui/run", (req, res) => {
  exec("jadx-gui", (error, stdout, stderr) => {
    if (error) {
      console.error("Error running JD-GUI:", error);
      return res.status(500).json({ error: "Error running JD-GUI" });
    }

    console.log("JD-GUI launched successfully");
    res.status(200).json({ message: "JD-GUI launched successfully" });
  });
});

app.post("/classyshark/run", (req,res) => {
  exec("java -jar /home/anshul/classyshark.jar", (error,stdout,stderr) => {
    if(error){
      console.error("Error running classyshark: ",error);
      return res.status(500).json({error: "Error running classyshark"})
    }

    console.log("Classyshark launched successfully")
    res.status(200).json({message: "Classyshark launced successfully"})
  })
})

app.post("/d2j-dex2jar/run", upload.single("apkFile"), (req, res) => {
  console.log("--------------------------------");
  console.log(req.file);
  const apkFilePath = req.file.path;

  if (!apkFilePath) {
    return res.status(400).json({ error: "No APK file uploaded" });
  }

  const outputJar = path.join(__dirname, "output.jar");

  exec(
    `d2j-dex2jar ${apkFilePath} -o ${outputJar}`,
    (error, stdout, stderr) => {
      if (error) {
        console.error("Error running d2j-dex2jar:", error);
        return res.status(500).json({ error: "Error running d2j-dex2jar" });
      }

      console.log("Output JAR path : ", outputJar);

      if (fs.existsSync(outputJar)) {
        res.setHeader("Content-Type", "application/java-archive");
        res.setHeader(
          "Content-Disposition",
          'attachment; filename="output.jar"'
        );

        const fileStream = fs.createReadStream(outputJar);
        fileStream.pipe(res);
      } else {
        res.status(404).json({ error: "File not found" });
      }
    }
  );
});

app.post("/btscanner/run", (req, res) => {
  exec("hciconfig", (error, stdout, stderr) => {
    if (error) {
      console.error("Error running hciconfig : ", error);
      return res.status(500).json({ error: "Error running hciconfig" });
    }
  });

  // exec("hciconfig hc1 up", (error,stdout,stderr) => {
  //   if(error){
  //     console.error("Error running hciconfig hci1 up : ",error)
  //     return res.status(500).json({ error: "Error running hciconfig hci1 up" });
  //   }
  // })

  // exec("hcitool scan", (error,stdout,stderr) => {
  //   if(error){
  //     console.error("Error running hcitool scan : ",error)
  //     return res.status(500).json({ error: "Error running hcitool scan" });
  //   }
  // })

  console.log("Btscanner launched successfully");
  res.status(200).json({ message: "Btscanner launched successfully" });
});

app.listen(port, () => {
  console.log(`Server is listening on port ${port}`);
});
